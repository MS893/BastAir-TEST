const CACHE_NAME = `bastair-cache-<%= Time.now.to_i %>`;

// Liste des URLs à mettre en cache dès l'installation du service worker.
// Nous mettons en cache la page d'accueil (le tableau de bord) et les assets principaux.
const PRECACHE_URLS = [
  '/', // La page d'accueil/dashboard
  '<%= signalements_path %>',         // La page des signalements
  '<%= check_list_path %>',           // La page check list
  '<%= asset_path("application.js") %>',
  '<%= asset_path("application.css") %>'
];

// Étape d'installation : on ouvre le cache et on y ajoute nos fichiers.
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(PRECACHE_URLS))
      .then(() => self.skipWaiting())
  );
});

// Étape d'activation : on supprime les anciens caches pour ne garder que le nouveau.
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.filter(name => name.startsWith('bastair-cache-') && name !== CACHE_NAME)
                  .map(name => caches.delete(name))
      );
    })
  );
});

// Étape de fetch : on intercepte les requêtes réseau.
self.addEventListener('fetch', (event) => {
  // On ne gère que les requêtes GET
  if (event.request.method !== 'GET') {
    return;
  }

  event.respondWith(
    caches.match(event.request)
      .then(cachedResponse => {
        // Si la ressource est dans le cache, on la retourne.
        return cachedResponse || fetch(event.request);
      })
  );
});

// --- Étape de synchronisation (Background Sync) ---
// Cet événement est déclenché par le navigateur quand la connexion est de retour.
self.addEventListener('sync', (event) => {
  // On vérifie le "tag" pour savoir quel type de synchronisation effectuer.
  if (event.tag === 'sync-new-signalement') {
    console.log('Service Worker: Synchronisation des nouveaux signalements...');
    event.waitUntil(syncNewSignalements());
  }
});

// Fonction qui lit les données depuis IndexedDB et les envoie au serveur.
function syncNewSignalements() {
  // On doit importer la librairie idb pour interagir avec IndexedDB
  importScripts('https://cdn.jsdelivr.net/npm/idb@7/build/umd.js');

  return idb.openDB('bastair-offline-db', 1).then(db => {
    // On récupère tous les signalements en attente
    return db.getAll('pending-signalements').then(signalements => {
      // On crée une promesse pour chaque envoi au serveur
      const syncPromises = signalements.map(signalement => {
        console.log('Service Worker: Envoi du signalement', signalement);
        // On reconstruit la requête POST comme si elle venait du formulaire
        return fetch(`/avions/${signalement.avion_id}/signalements`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': signalement.csrfToken
          },
          body: JSON.stringify({ signalement: { description: signalement.description } })
        }).then(response => {
          if (response.ok) {
            // Si le serveur a bien reçu les données, on supprime l'entrée de IndexedDB
            return db.delete('pending-signalements', signalement.id);
          }
        });
      });
      return Promise.all(syncPromises);
    });
  });
}

// --- Étape de réception des notifications Push ---

// Le service worker écoute l'événement "push" envoyé par le serveur.
self.addEventListener("push", async (event) => {
  const { title, options } = await event.data.json();
  // Il affiche la notification avec les informations reçues.
  event.waitUntil(self.registration.showNotification(title, options));
});

// Le service worker écoute le clic sur une notification.
self.addEventListener("notificationclick", function(event) {
  event.notification.close(); // Ferme la notification
  // Ouvre la page spécifiée dans les données de la notification.
  event.waitUntil(
    clients.matchAll({ type: "window" }).then((clientList) => {
      // Si l'onglet est déjà ouvert, on le focus.
      const client = clientList.find(c => c.url === event.notification.data.path && 'focus' in c);
      if (client) return client.focus();
      // Sinon, on ouvre un nouvel onglet.
      if (clients.openWindow) return clients.openWindow(event.notification.data.path);
    })
  );
});
